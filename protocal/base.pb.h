// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: base.proto

#ifndef PROTOBUF_base_2eproto__INCLUDED
#define PROTOBUF_base_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace network {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_base_2eproto();
void protobuf_AssignDesc_base_2eproto();
void protobuf_ShutdownFile_base_2eproto();

class RegisterRequest;
class RegisterReply;
class LoginRequest;
class LoginReply;
class LogoutRequest;
class LogoutReply;
class EnterRoom;
class SingleRoom;
class SingleRoom_RoomPlayer;
class Rooms;
class ReadyToStart;
class StartReply;
class SinglePlayerInfo;
class GameInfo;
class Talk;
class Gossip;

enum MessageType {
  MSG_LOGIN_REQ = 1,
  MSG_LOGIN_REP = 2,
  MSG_READY = 3,
  MSG_START_REP = 4,
  MSG_SINGLE_PLAYER = 5,
  MSG_GAME = 6,
  MSG_TALK = 7,
  MSG_GOSSIP = 8,
  MSG_ENTER_ROOM = 9,
  MSG_SINGLE_ROOM = 10,
  MSG_ROOMS = 11,
  MSG_LOGOUT_REQ = 12,
  MSG_LOGOUT_REP = 13,
  MSG_REGISTER_REQ = 14,
  MSG_REGISTER_REP = 15
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = MSG_LOGIN_REQ;
const MessageType MessageType_MAX = MSG_REGISTER_REP;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum GossipType {
  GOSSIP_TALK = 1,
  GOSSIP_NOTICE = 2
};
bool GossipType_IsValid(int value);
const GossipType GossipType_MIN = GOSSIP_TALK;
const GossipType GossipType_MAX = GOSSIP_NOTICE;
const int GossipType_ARRAYSIZE = GossipType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GossipType_descriptor();
inline const ::std::string& GossipType_Name(GossipType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GossipType_descriptor(), value);
}
inline bool GossipType_Parse(
    const ::std::string& name, GossipType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GossipType>(
    GossipType_descriptor(), name, value);
}
// ===================================================================

class RegisterRequest : public ::google::protobuf::Message {
 public:
  RegisterRequest();
  virtual ~RegisterRequest();

  RegisterRequest(const RegisterRequest& from);

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRequest& default_instance();

  void Swap(RegisterRequest* other);

  // implements Message ----------------------------------------------

  RegisterRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterRequest& from);
  void MergeFrom(const RegisterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // optional string user_password = 2;
  inline bool has_user_password() const;
  inline void clear_user_password();
  static const int kUserPasswordFieldNumber = 2;
  inline const ::std::string& user_password() const;
  inline void set_user_password(const ::std::string& value);
  inline void set_user_password(const char* value);
  inline void set_user_password(const char* value, size_t size);
  inline ::std::string* mutable_user_password();
  inline ::std::string* release_user_password();
  inline void set_allocated_user_password(::std::string* user_password);

  // optional string nickname = 3;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 3;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional string mobile = 4;
  inline bool has_mobile() const;
  inline void clear_mobile();
  static const int kMobileFieldNumber = 4;
  inline const ::std::string& mobile() const;
  inline void set_mobile(const ::std::string& value);
  inline void set_mobile(const char* value);
  inline void set_mobile(const char* value, size_t size);
  inline ::std::string* mutable_mobile();
  inline ::std::string* release_mobile();
  inline void set_allocated_mobile(::std::string* mobile);

  // optional string email = 5;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 5;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // @@protoc_insertion_point(class_scope:network.RegisterRequest)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_password();
  inline void clear_has_user_password();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_mobile();
  inline void clear_has_mobile();
  inline void set_has_email();
  inline void clear_has_email();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_id_;
  ::std::string* user_password_;
  ::std::string* nickname_;
  ::std::string* mobile_;
  ::std::string* email_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static RegisterRequest* default_instance_;
};
// -------------------------------------------------------------------

class RegisterReply : public ::google::protobuf::Message {
 public:
  RegisterReply();
  virtual ~RegisterReply();

  RegisterReply(const RegisterReply& from);

  inline RegisterReply& operator=(const RegisterReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterReply& default_instance();

  void Swap(RegisterReply* other);

  // implements Message ----------------------------------------------

  RegisterReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterReply& from);
  void MergeFrom(const RegisterReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:network.RegisterReply)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static RegisterReply* default_instance_;
};
// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // optional string user_password = 2;
  inline bool has_user_password() const;
  inline void clear_user_password();
  static const int kUserPasswordFieldNumber = 2;
  inline const ::std::string& user_password() const;
  inline void set_user_password(const ::std::string& value);
  inline void set_user_password(const char* value);
  inline void set_user_password(const char* value, size_t size);
  inline ::std::string* mutable_user_password();
  inline ::std::string* release_user_password();
  inline void set_allocated_user_password(::std::string* user_password);

  // @@protoc_insertion_point(class_scope:network.LoginRequest)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_password();
  inline void clear_has_user_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_id_;
  ::std::string* user_password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginReply : public ::google::protobuf::Message {
 public:
  LoginReply();
  virtual ~LoginReply();

  LoginReply(const LoginReply& from);

  inline LoginReply& operator=(const LoginReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginReply& default_instance();

  void Swap(LoginReply* other);

  // implements Message ----------------------------------------------

  LoginReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginReply& from);
  void MergeFrom(const LoginReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 serial_num = 1;
  inline bool has_serial_num() const;
  inline void clear_serial_num();
  static const int kSerialNumFieldNumber = 1;
  inline ::google::protobuf::uint32 serial_num() const;
  inline void set_serial_num(::google::protobuf::uint32 value);

  // optional uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional string nickname = 3;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 3;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // @@protoc_insertion_point(class_scope:network.LoginReply)
 private:
  inline void set_has_serial_num();
  inline void clear_has_serial_num();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_nickname();
  inline void clear_has_nickname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 serial_num_;
  ::google::protobuf::uint32 state_;
  ::std::string* nickname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static LoginReply* default_instance_;
};
// -------------------------------------------------------------------

class LogoutRequest : public ::google::protobuf::Message {
 public:
  LogoutRequest();
  virtual ~LogoutRequest();

  LogoutRequest(const LogoutRequest& from);

  inline LogoutRequest& operator=(const LogoutRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutRequest& default_instance();

  void Swap(LogoutRequest* other);

  // implements Message ----------------------------------------------

  LogoutRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutRequest& from);
  void MergeFrom(const LogoutRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:network.LogoutRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static LogoutRequest* default_instance_;
};
// -------------------------------------------------------------------

class LogoutReply : public ::google::protobuf::Message {
 public:
  LogoutReply();
  virtual ~LogoutReply();

  LogoutReply(const LogoutReply& from);

  inline LogoutReply& operator=(const LogoutReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutReply& default_instance();

  void Swap(LogoutReply* other);

  // implements Message ----------------------------------------------

  LogoutReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutReply& from);
  void MergeFrom(const LogoutReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 args = 1;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 1;
  inline ::google::protobuf::uint32 args(int index) const;
  inline void set_args(int index, ::google::protobuf::uint32 value);
  inline void add_args(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      args() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_args();

  // @@protoc_insertion_point(class_scope:network.LogoutReply)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > args_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static LogoutReply* default_instance_;
};
// -------------------------------------------------------------------

class EnterRoom : public ::google::protobuf::Message {
 public:
  EnterRoom();
  virtual ~EnterRoom();

  EnterRoom(const EnterRoom& from);

  inline EnterRoom& operator=(const EnterRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoom& default_instance();

  void Swap(EnterRoom* other);

  // implements Message ----------------------------------------------

  EnterRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterRoom& from);
  void MergeFrom(const EnterRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 room_id = 1;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 1;
  inline ::google::protobuf::uint32 room_id() const;
  inline void set_room_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:network.EnterRoom)
 private:
  inline void set_has_room_id();
  inline void clear_has_room_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 room_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static EnterRoom* default_instance_;
};
// -------------------------------------------------------------------

class SingleRoom_RoomPlayer : public ::google::protobuf::Message {
 public:
  SingleRoom_RoomPlayer();
  virtual ~SingleRoom_RoomPlayer();

  SingleRoom_RoomPlayer(const SingleRoom_RoomPlayer& from);

  inline SingleRoom_RoomPlayer& operator=(const SingleRoom_RoomPlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SingleRoom_RoomPlayer& default_instance();

  void Swap(SingleRoom_RoomPlayer* other);

  // implements Message ----------------------------------------------

  SingleRoom_RoomPlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SingleRoom_RoomPlayer& from);
  void MergeFrom(const SingleRoom_RoomPlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // optional uint32 player_nickname = 2;
  inline bool has_player_nickname() const;
  inline void clear_player_nickname();
  static const int kPlayerNicknameFieldNumber = 2;
  inline ::google::protobuf::uint32 player_nickname() const;
  inline void set_player_nickname(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:network.SingleRoom.RoomPlayer)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_player_nickname();
  inline void clear_has_player_nickname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::uint32 player_nickname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static SingleRoom_RoomPlayer* default_instance_;
};
// -------------------------------------------------------------------

class SingleRoom : public ::google::protobuf::Message {
 public:
  SingleRoom();
  virtual ~SingleRoom();

  SingleRoom(const SingleRoom& from);

  inline SingleRoom& operator=(const SingleRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SingleRoom& default_instance();

  void Swap(SingleRoom* other);

  // implements Message ----------------------------------------------

  SingleRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SingleRoom& from);
  void MergeFrom(const SingleRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SingleRoom_RoomPlayer RoomPlayer;

  // accessors -------------------------------------------------------

  // optional uint32 room_id = 1;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 1;
  inline ::google::protobuf::uint32 room_id() const;
  inline void set_room_id(::google::protobuf::uint32 value);

  // optional uint32 player_id = 3;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 3;
  inline ::google::protobuf::uint32 player_id() const;
  inline void set_player_id(::google::protobuf::uint32 value);

  // repeated .network.SingleRoom.RoomPlayer players = 2;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 2;
  inline const ::network::SingleRoom_RoomPlayer& players(int index) const;
  inline ::network::SingleRoom_RoomPlayer* mutable_players(int index);
  inline ::network::SingleRoom_RoomPlayer* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::network::SingleRoom_RoomPlayer >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::network::SingleRoom_RoomPlayer >*
      mutable_players();

  // @@protoc_insertion_point(class_scope:network.SingleRoom)
 private:
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_player_id();
  inline void clear_has_player_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 room_id_;
  ::google::protobuf::uint32 player_id_;
  ::google::protobuf::RepeatedPtrField< ::network::SingleRoom_RoomPlayer > players_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static SingleRoom* default_instance_;
};
// -------------------------------------------------------------------

class Rooms : public ::google::protobuf::Message {
 public:
  Rooms();
  virtual ~Rooms();

  Rooms(const Rooms& from);

  inline Rooms& operator=(const Rooms& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Rooms& default_instance();

  void Swap(Rooms* other);

  // implements Message ----------------------------------------------

  Rooms* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Rooms& from);
  void MergeFrom(const Rooms& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .network.SingleRoom rooms = 1;
  inline int rooms_size() const;
  inline void clear_rooms();
  static const int kRoomsFieldNumber = 1;
  inline const ::network::SingleRoom& rooms(int index) const;
  inline ::network::SingleRoom* mutable_rooms(int index);
  inline ::network::SingleRoom* add_rooms();
  inline const ::google::protobuf::RepeatedPtrField< ::network::SingleRoom >&
      rooms() const;
  inline ::google::protobuf::RepeatedPtrField< ::network::SingleRoom >*
      mutable_rooms();

  // @@protoc_insertion_point(class_scope:network.Rooms)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::network::SingleRoom > rooms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static Rooms* default_instance_;
};
// -------------------------------------------------------------------

class ReadyToStart : public ::google::protobuf::Message {
 public:
  ReadyToStart();
  virtual ~ReadyToStart();

  ReadyToStart(const ReadyToStart& from);

  inline ReadyToStart& operator=(const ReadyToStart& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadyToStart& default_instance();

  void Swap(ReadyToStart* other);

  // implements Message ----------------------------------------------

  ReadyToStart* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReadyToStart& from);
  void MergeFrom(const ReadyToStart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:network.ReadyToStart)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static ReadyToStart* default_instance_;
};
// -------------------------------------------------------------------

class StartReply : public ::google::protobuf::Message {
 public:
  StartReply();
  virtual ~StartReply();

  StartReply(const StartReply& from);

  inline StartReply& operator=(const StartReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartReply& default_instance();

  void Swap(StartReply* other);

  // implements Message ----------------------------------------------

  StartReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartReply& from);
  void MergeFrom(const StartReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:network.StartReply)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static StartReply* default_instance_;
};
// -------------------------------------------------------------------

class SinglePlayerInfo : public ::google::protobuf::Message {
 public:
  SinglePlayerInfo();
  virtual ~SinglePlayerInfo();

  SinglePlayerInfo(const SinglePlayerInfo& from);

  inline SinglePlayerInfo& operator=(const SinglePlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SinglePlayerInfo& default_instance();

  void Swap(SinglePlayerInfo* other);

  // implements Message ----------------------------------------------

  SinglePlayerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SinglePlayerInfo& from);
  void MergeFrom(const SinglePlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 seat = 21;
  inline bool has_seat() const;
  inline void clear_seat();
  static const int kSeatFieldNumber = 21;
  inline ::google::protobuf::uint32 seat() const;
  inline void set_seat(::google::protobuf::uint32 value);

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 team = 2;
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 2;
  inline ::google::protobuf::uint32 team() const;
  inline void set_team(::google::protobuf::uint32 value);

  // optional string nickname = 20;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 20;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional uint32 role_id = 4;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 4;
  inline ::google::protobuf::uint32 role_id() const;
  inline void set_role_id(::google::protobuf::uint32 value);

  // optional uint32 hand_count = 5;
  inline bool has_hand_count() const;
  inline void clear_hand_count();
  static const int kHandCountFieldNumber = 5;
  inline ::google::protobuf::uint32 hand_count() const;
  inline void set_hand_count(::google::protobuf::uint32 value);

  // optional uint32 heal_count = 6;
  inline bool has_heal_count() const;
  inline void clear_heal_count();
  static const int kHealCountFieldNumber = 6;
  inline ::google::protobuf::uint32 heal_count() const;
  inline void set_heal_count(::google::protobuf::uint32 value);

  // repeated uint32 my_ex_card_place = 7;
  inline int my_ex_card_place_size() const;
  inline void clear_my_ex_card_place();
  static const int kMyExCardPlaceFieldNumber = 7;
  inline ::google::protobuf::uint32 my_ex_card_place(int index) const;
  inline void set_my_ex_card_place(int index, ::google::protobuf::uint32 value);
  inline void add_my_ex_card_place(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      my_ex_card_place() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_my_ex_card_place();

  // repeated uint32 gain_ex_card = 8;
  inline int gain_ex_card_size() const;
  inline void clear_gain_ex_card();
  static const int kGainExCardFieldNumber = 8;
  inline ::google::protobuf::uint32 gain_ex_card(int index) const;
  inline void set_gain_ex_card(int index, ::google::protobuf::uint32 value);
  inline void add_gain_ex_card(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      gain_ex_card() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_gain_ex_card();

  // repeated uint32 basic_cards = 9;
  inline int basic_cards_size() const;
  inline void clear_basic_cards();
  static const int kBasicCardsFieldNumber = 9;
  inline ::google::protobuf::uint32 basic_cards(int index) const;
  inline void set_basic_cards(int index, ::google::protobuf::uint32 value);
  inline void add_basic_cards(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      basic_cards() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_basic_cards();

  // optional uint32 gem = 10;
  inline bool has_gem() const;
  inline void clear_gem();
  static const int kGemFieldNumber = 10;
  inline ::google::protobuf::uint32 gem() const;
  inline void set_gem(::google::protobuf::uint32 value);

  // optional uint32 crystal = 11;
  inline bool has_crystal() const;
  inline void clear_crystal();
  static const int kCrystalFieldNumber = 11;
  inline ::google::protobuf::uint32 crystal() const;
  inline void set_crystal(::google::protobuf::uint32 value);

  // optional uint32 yellow_energy = 12;
  inline bool has_yellow_energy() const;
  inline void clear_yellow_energy();
  static const int kYellowEnergyFieldNumber = 12;
  inline ::google::protobuf::uint32 yellow_energy() const;
  inline void set_yellow_energy(::google::protobuf::uint32 value);

  // optional uint32 blue_energy = 13;
  inline bool has_blue_energy() const;
  inline void clear_blue_energy();
  static const int kBlueEnergyFieldNumber = 13;
  inline ::google::protobuf::uint32 blue_energy() const;
  inline void set_blue_energy(::google::protobuf::uint32 value);

  // optional uint32 covered_count = 14;
  inline bool has_covered_count() const;
  inline void clear_covered_count();
  static const int kCoveredCountFieldNumber = 14;
  inline ::google::protobuf::uint32 covered_count() const;
  inline void set_covered_count(::google::protobuf::uint32 value);

  // optional bool is_knelt = 3;
  inline bool has_is_knelt() const;
  inline void clear_is_knelt();
  static const int kIsKneltFieldNumber = 3;
  inline bool is_knelt() const;
  inline void set_is_knelt(bool value);

  // repeated uint32 hands = 15;
  inline int hands_size() const;
  inline void clear_hands();
  static const int kHandsFieldNumber = 15;
  inline ::google::protobuf::uint32 hands(int index) const;
  inline void set_hands(int index, ::google::protobuf::uint32 value);
  inline void add_hands(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      hands() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_hands();

  // repeated uint32 covereds = 16;
  inline int covereds_size() const;
  inline void clear_covereds();
  static const int kCoveredsFieldNumber = 16;
  inline ::google::protobuf::uint32 covereds(int index) const;
  inline void set_covereds(int index, ::google::protobuf::uint32 value);
  inline void add_covereds(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      covereds() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_covereds();

  // optional uint32 max_hand = 22;
  inline bool has_max_hand() const;
  inline void clear_max_hand();
  static const int kMaxHandFieldNumber = 22;
  inline ::google::protobuf::uint32 max_hand() const;
  inline void set_max_hand(::google::protobuf::uint32 value);

  // repeated string delete_field = 30;
  inline int delete_field_size() const;
  inline void clear_delete_field();
  static const int kDeleteFieldFieldNumber = 30;
  inline const ::std::string& delete_field(int index) const;
  inline ::std::string* mutable_delete_field(int index);
  inline void set_delete_field(int index, const ::std::string& value);
  inline void set_delete_field(int index, const char* value);
  inline void set_delete_field(int index, const char* value, size_t size);
  inline ::std::string* add_delete_field();
  inline void add_delete_field(const ::std::string& value);
  inline void add_delete_field(const char* value);
  inline void add_delete_field(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& delete_field() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_delete_field();

  // @@protoc_insertion_point(class_scope:network.SinglePlayerInfo)
 private:
  inline void set_has_seat();
  inline void clear_has_seat();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_team();
  inline void clear_has_team();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_hand_count();
  inline void clear_has_hand_count();
  inline void set_has_heal_count();
  inline void clear_has_heal_count();
  inline void set_has_gem();
  inline void clear_has_gem();
  inline void set_has_crystal();
  inline void clear_has_crystal();
  inline void set_has_yellow_energy();
  inline void clear_has_yellow_energy();
  inline void set_has_blue_energy();
  inline void clear_has_blue_energy();
  inline void set_has_covered_count();
  inline void clear_has_covered_count();
  inline void set_has_is_knelt();
  inline void clear_has_is_knelt();
  inline void set_has_max_hand();
  inline void clear_has_max_hand();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 seat_;
  ::google::protobuf::uint32 id_;
  ::std::string* nickname_;
  ::google::protobuf::uint32 team_;
  ::google::protobuf::uint32 role_id_;
  ::google::protobuf::uint32 hand_count_;
  ::google::protobuf::uint32 heal_count_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > my_ex_card_place_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > gain_ex_card_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > basic_cards_;
  ::google::protobuf::uint32 gem_;
  ::google::protobuf::uint32 crystal_;
  ::google::protobuf::uint32 yellow_energy_;
  ::google::protobuf::uint32 blue_energy_;
  ::google::protobuf::uint32 covered_count_;
  bool is_knelt_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > hands_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > covereds_;
  ::google::protobuf::RepeatedPtrField< ::std::string> delete_field_;
  ::google::protobuf::uint32 max_hand_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static SinglePlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameInfo : public ::google::protobuf::Message {
 public:
  GameInfo();
  virtual ~GameInfo();

  GameInfo(const GameInfo& from);

  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameInfo& default_instance();

  void Swap(GameInfo* other);

  // implements Message ----------------------------------------------

  GameInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameInfo& from);
  void MergeFrom(const GameInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .network.SinglePlayerInfo player_infos = 1;
  inline int player_infos_size() const;
  inline void clear_player_infos();
  static const int kPlayerInfosFieldNumber = 1;
  inline const ::network::SinglePlayerInfo& player_infos(int index) const;
  inline ::network::SinglePlayerInfo* mutable_player_infos(int index);
  inline ::network::SinglePlayerInfo* add_player_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::network::SinglePlayerInfo >&
      player_infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::network::SinglePlayerInfo >*
      mutable_player_infos();

  // optional uint32 red_morale = 2;
  inline bool has_red_morale() const;
  inline void clear_red_morale();
  static const int kRedMoraleFieldNumber = 2;
  inline ::google::protobuf::uint32 red_morale() const;
  inline void set_red_morale(::google::protobuf::uint32 value);

  // optional uint32 blue_morale = 3;
  inline bool has_blue_morale() const;
  inline void clear_blue_morale();
  static const int kBlueMoraleFieldNumber = 3;
  inline ::google::protobuf::uint32 blue_morale() const;
  inline void set_blue_morale(::google::protobuf::uint32 value);

  // optional uint32 red_gem = 4;
  inline bool has_red_gem() const;
  inline void clear_red_gem();
  static const int kRedGemFieldNumber = 4;
  inline ::google::protobuf::uint32 red_gem() const;
  inline void set_red_gem(::google::protobuf::uint32 value);

  // optional uint32 blue_gem = 5;
  inline bool has_blue_gem() const;
  inline void clear_blue_gem();
  static const int kBlueGemFieldNumber = 5;
  inline ::google::protobuf::uint32 blue_gem() const;
  inline void set_blue_gem(::google::protobuf::uint32 value);

  // optional uint32 red_crystal = 6;
  inline bool has_red_crystal() const;
  inline void clear_red_crystal();
  static const int kRedCrystalFieldNumber = 6;
  inline ::google::protobuf::uint32 red_crystal() const;
  inline void set_red_crystal(::google::protobuf::uint32 value);

  // optional uint32 blue_crystal = 7;
  inline bool has_blue_crystal() const;
  inline void clear_blue_crystal();
  static const int kBlueCrystalFieldNumber = 7;
  inline ::google::protobuf::uint32 blue_crystal() const;
  inline void set_blue_crystal(::google::protobuf::uint32 value);

  // optional uint32 red_grail = 8;
  inline bool has_red_grail() const;
  inline void clear_red_grail();
  static const int kRedGrailFieldNumber = 8;
  inline ::google::protobuf::uint32 red_grail() const;
  inline void set_red_grail(::google::protobuf::uint32 value);

  // optional uint32 blue_grail = 9;
  inline bool has_blue_grail() const;
  inline void clear_blue_grail();
  static const int kBlueGrailFieldNumber = 9;
  inline ::google::protobuf::uint32 blue_grail() const;
  inline void set_blue_grail(::google::protobuf::uint32 value);

  // optional uint32 pile = 10;
  inline bool has_pile() const;
  inline void clear_pile();
  static const int kPileFieldNumber = 10;
  inline ::google::protobuf::uint32 pile() const;
  inline void set_pile(::google::protobuf::uint32 value);

  // optional uint32 discard = 11;
  inline bool has_discard() const;
  inline void clear_discard();
  static const int kDiscardFieldNumber = 11;
  inline ::google::protobuf::uint32 discard() const;
  inline void set_discard(::google::protobuf::uint32 value);

  // repeated uint32 show_cards = 12;
  inline int show_cards_size() const;
  inline void clear_show_cards();
  static const int kShowCardsFieldNumber = 12;
  inline ::google::protobuf::uint32 show_cards(int index) const;
  inline void set_show_cards(int index, ::google::protobuf::uint32 value);
  inline void add_show_cards(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      show_cards() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_show_cards();

  // optional uint32 show_from = 13;
  inline bool has_show_from() const;
  inline void clear_show_from();
  static const int kShowFromFieldNumber = 13;
  inline ::google::protobuf::uint32 show_from() const;
  inline void set_show_from(::google::protobuf::uint32 value);

  // repeated string delete_field = 15;
  inline int delete_field_size() const;
  inline void clear_delete_field();
  static const int kDeleteFieldFieldNumber = 15;
  inline const ::std::string& delete_field(int index) const;
  inline ::std::string* mutable_delete_field(int index);
  inline void set_delete_field(int index, const ::std::string& value);
  inline void set_delete_field(int index, const char* value);
  inline void set_delete_field(int index, const char* value, size_t size);
  inline ::std::string* add_delete_field();
  inline void add_delete_field(const ::std::string& value);
  inline void add_delete_field(const char* value);
  inline void add_delete_field(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& delete_field() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_delete_field();

  // @@protoc_insertion_point(class_scope:network.GameInfo)
 private:
  inline void set_has_red_morale();
  inline void clear_has_red_morale();
  inline void set_has_blue_morale();
  inline void clear_has_blue_morale();
  inline void set_has_red_gem();
  inline void clear_has_red_gem();
  inline void set_has_blue_gem();
  inline void clear_has_blue_gem();
  inline void set_has_red_crystal();
  inline void clear_has_red_crystal();
  inline void set_has_blue_crystal();
  inline void clear_has_blue_crystal();
  inline void set_has_red_grail();
  inline void clear_has_red_grail();
  inline void set_has_blue_grail();
  inline void clear_has_blue_grail();
  inline void set_has_pile();
  inline void clear_has_pile();
  inline void set_has_discard();
  inline void clear_has_discard();
  inline void set_has_show_from();
  inline void clear_has_show_from();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::network::SinglePlayerInfo > player_infos_;
  ::google::protobuf::uint32 red_morale_;
  ::google::protobuf::uint32 blue_morale_;
  ::google::protobuf::uint32 red_gem_;
  ::google::protobuf::uint32 blue_gem_;
  ::google::protobuf::uint32 red_crystal_;
  ::google::protobuf::uint32 blue_crystal_;
  ::google::protobuf::uint32 red_grail_;
  ::google::protobuf::uint32 blue_grail_;
  ::google::protobuf::uint32 pile_;
  ::google::protobuf::uint32 discard_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > show_cards_;
  ::google::protobuf::RepeatedPtrField< ::std::string> delete_field_;
  ::google::protobuf::uint32 show_from_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static GameInfo* default_instance_;
};
// -------------------------------------------------------------------

class Talk : public ::google::protobuf::Message {
 public:
  Talk();
  virtual ~Talk();

  Talk(const Talk& from);

  inline Talk& operator=(const Talk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Talk& default_instance();

  void Swap(Talk* other);

  // implements Message ----------------------------------------------

  Talk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Talk& from);
  void MergeFrom(const Talk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string txt = 1;
  inline bool has_txt() const;
  inline void clear_txt();
  static const int kTxtFieldNumber = 1;
  inline const ::std::string& txt() const;
  inline void set_txt(const ::std::string& value);
  inline void set_txt(const char* value);
  inline void set_txt(const char* value, size_t size);
  inline ::std::string* mutable_txt();
  inline ::std::string* release_txt();
  inline void set_allocated_txt(::std::string* txt);

  // @@protoc_insertion_point(class_scope:network.Talk)
 private:
  inline void set_has_txt();
  inline void clear_has_txt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* txt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static Talk* default_instance_;
};
// -------------------------------------------------------------------

class Gossip : public ::google::protobuf::Message {
 public:
  Gossip();
  virtual ~Gossip();

  Gossip(const Gossip& from);

  inline Gossip& operator=(const Gossip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Gossip& default_instance();

  void Swap(Gossip* other);

  // implements Message ----------------------------------------------

  Gossip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Gossip& from);
  void MergeFrom(const Gossip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .network.GossipType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::network::GossipType type() const;
  inline void set_type(::network::GossipType value);

  // optional string txt = 2;
  inline bool has_txt() const;
  inline void clear_txt();
  static const int kTxtFieldNumber = 2;
  inline const ::std::string& txt() const;
  inline void set_txt(const ::std::string& value);
  inline void set_txt(const char* value);
  inline void set_txt(const char* value, size_t size);
  inline ::std::string* mutable_txt();
  inline ::std::string* release_txt();
  inline void set_allocated_txt(::std::string* txt);

  // optional uint32 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:network.Gossip)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_txt();
  inline void clear_has_txt();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* txt_;
  int type_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_base_2eproto();
  friend void protobuf_AssignDesc_base_2eproto();
  friend void protobuf_ShutdownFile_base_2eproto();

  void InitAsDefaultInstance();
  static Gossip* default_instance_;
};
// ===================================================================


// ===================================================================

// RegisterRequest

// optional string user_id = 1;
inline bool RegisterRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterRequest::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& RegisterRequest::user_id() const {
  return *user_id_;
}
inline void RegisterRequest::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void RegisterRequest::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void RegisterRequest::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRequest::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* RegisterRequest::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterRequest::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string user_password = 2;
inline bool RegisterRequest::has_user_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterRequest::set_has_user_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterRequest::clear_has_user_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterRequest::clear_user_password() {
  if (user_password_ != &::google::protobuf::internal::kEmptyString) {
    user_password_->clear();
  }
  clear_has_user_password();
}
inline const ::std::string& RegisterRequest::user_password() const {
  return *user_password_;
}
inline void RegisterRequest::set_user_password(const ::std::string& value) {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    user_password_ = new ::std::string;
  }
  user_password_->assign(value);
}
inline void RegisterRequest::set_user_password(const char* value) {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    user_password_ = new ::std::string;
  }
  user_password_->assign(value);
}
inline void RegisterRequest::set_user_password(const char* value, size_t size) {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    user_password_ = new ::std::string;
  }
  user_password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRequest::mutable_user_password() {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    user_password_ = new ::std::string;
  }
  return user_password_;
}
inline ::std::string* RegisterRequest::release_user_password() {
  clear_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_password_;
    user_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterRequest::set_allocated_user_password(::std::string* user_password) {
  if (user_password_ != &::google::protobuf::internal::kEmptyString) {
    delete user_password_;
  }
  if (user_password) {
    set_has_user_password();
    user_password_ = user_password;
  } else {
    clear_has_user_password();
    user_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nickname = 3;
inline bool RegisterRequest::has_nickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterRequest::set_has_nickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterRequest::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterRequest::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& RegisterRequest::nickname() const {
  return *nickname_;
}
inline void RegisterRequest::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void RegisterRequest::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void RegisterRequest::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRequest::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* RegisterRequest::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterRequest::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobile = 4;
inline bool RegisterRequest::has_mobile() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterRequest::set_has_mobile() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterRequest::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterRequest::clear_mobile() {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    mobile_->clear();
  }
  clear_has_mobile();
}
inline const ::std::string& RegisterRequest::mobile() const {
  return *mobile_;
}
inline void RegisterRequest::set_mobile(const ::std::string& value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void RegisterRequest::set_mobile(const char* value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void RegisterRequest::set_mobile(const char* value, size_t size) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRequest::mutable_mobile() {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  return mobile_;
}
inline ::std::string* RegisterRequest::release_mobile() {
  clear_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobile_;
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterRequest::set_allocated_mobile(::std::string* mobile) {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    delete mobile_;
  }
  if (mobile) {
    set_has_mobile();
    mobile_ = mobile;
  } else {
    clear_has_mobile();
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 5;
inline bool RegisterRequest::has_email() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegisterRequest::set_has_email() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegisterRequest::clear_has_email() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegisterRequest::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& RegisterRequest::email() const {
  return *email_;
}
inline void RegisterRequest::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void RegisterRequest::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void RegisterRequest::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRequest::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* RegisterRequest::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterRequest::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RegisterReply

// optional uint32 state = 1;
inline bool RegisterReply::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterReply::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterReply::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 RegisterReply::state() const {
  return state_;
}
inline void RegisterReply::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// LoginRequest

// optional string user_id = 1;
inline bool LoginRequest::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& LoginRequest::user_id() const {
  return *user_id_;
}
inline void LoginRequest::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void LoginRequest::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void LoginRequest::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* LoginRequest::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string user_password = 2;
inline bool LoginRequest::has_user_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_user_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_user_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_user_password() {
  if (user_password_ != &::google::protobuf::internal::kEmptyString) {
    user_password_->clear();
  }
  clear_has_user_password();
}
inline const ::std::string& LoginRequest::user_password() const {
  return *user_password_;
}
inline void LoginRequest::set_user_password(const ::std::string& value) {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    user_password_ = new ::std::string;
  }
  user_password_->assign(value);
}
inline void LoginRequest::set_user_password(const char* value) {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    user_password_ = new ::std::string;
  }
  user_password_->assign(value);
}
inline void LoginRequest::set_user_password(const char* value, size_t size) {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    user_password_ = new ::std::string;
  }
  user_password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_user_password() {
  set_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    user_password_ = new ::std::string;
  }
  return user_password_;
}
inline ::std::string* LoginRequest::release_user_password() {
  clear_has_user_password();
  if (user_password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_password_;
    user_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_user_password(::std::string* user_password) {
  if (user_password_ != &::google::protobuf::internal::kEmptyString) {
    delete user_password_;
  }
  if (user_password) {
    set_has_user_password();
    user_password_ = user_password;
  } else {
    clear_has_user_password();
    user_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginReply

// optional uint32 serial_num = 1;
inline bool LoginReply::has_serial_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginReply::set_has_serial_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginReply::clear_has_serial_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginReply::clear_serial_num() {
  serial_num_ = 0u;
  clear_has_serial_num();
}
inline ::google::protobuf::uint32 LoginReply::serial_num() const {
  return serial_num_;
}
inline void LoginReply::set_serial_num(::google::protobuf::uint32 value) {
  set_has_serial_num();
  serial_num_ = value;
}

// optional uint32 state = 2;
inline bool LoginReply::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginReply::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginReply::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginReply::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 LoginReply::state() const {
  return state_;
}
inline void LoginReply::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional string nickname = 3;
inline bool LoginReply::has_nickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginReply::set_has_nickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginReply::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginReply::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& LoginReply::nickname() const {
  return *nickname_;
}
inline void LoginReply::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void LoginReply::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void LoginReply::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReply::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* LoginReply::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReply::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LogoutRequest

// -------------------------------------------------------------------

// LogoutReply

// repeated uint32 args = 1;
inline int LogoutReply::args_size() const {
  return args_.size();
}
inline void LogoutReply::clear_args() {
  args_.Clear();
}
inline ::google::protobuf::uint32 LogoutReply::args(int index) const {
  return args_.Get(index);
}
inline void LogoutReply::set_args(int index, ::google::protobuf::uint32 value) {
  args_.Set(index, value);
}
inline void LogoutReply::add_args(::google::protobuf::uint32 value) {
  args_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
LogoutReply::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
LogoutReply::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// EnterRoom

// optional uint32 room_id = 1;
inline bool EnterRoom::has_room_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoom::set_has_room_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoom::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoom::clear_room_id() {
  room_id_ = 0u;
  clear_has_room_id();
}
inline ::google::protobuf::uint32 EnterRoom::room_id() const {
  return room_id_;
}
inline void EnterRoom::set_room_id(::google::protobuf::uint32 value) {
  set_has_room_id();
  room_id_ = value;
}

// -------------------------------------------------------------------

// SingleRoom_RoomPlayer

// optional uint32 player_id = 1;
inline bool SingleRoom_RoomPlayer::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SingleRoom_RoomPlayer::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SingleRoom_RoomPlayer::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SingleRoom_RoomPlayer::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 SingleRoom_RoomPlayer::player_id() const {
  return player_id_;
}
inline void SingleRoom_RoomPlayer::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
}

// optional uint32 player_nickname = 2;
inline bool SingleRoom_RoomPlayer::has_player_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SingleRoom_RoomPlayer::set_has_player_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SingleRoom_RoomPlayer::clear_has_player_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SingleRoom_RoomPlayer::clear_player_nickname() {
  player_nickname_ = 0u;
  clear_has_player_nickname();
}
inline ::google::protobuf::uint32 SingleRoom_RoomPlayer::player_nickname() const {
  return player_nickname_;
}
inline void SingleRoom_RoomPlayer::set_player_nickname(::google::protobuf::uint32 value) {
  set_has_player_nickname();
  player_nickname_ = value;
}

// -------------------------------------------------------------------

// SingleRoom

// optional uint32 room_id = 1;
inline bool SingleRoom::has_room_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SingleRoom::set_has_room_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SingleRoom::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SingleRoom::clear_room_id() {
  room_id_ = 0u;
  clear_has_room_id();
}
inline ::google::protobuf::uint32 SingleRoom::room_id() const {
  return room_id_;
}
inline void SingleRoom::set_room_id(::google::protobuf::uint32 value) {
  set_has_room_id();
  room_id_ = value;
}

// optional uint32 player_id = 3;
inline bool SingleRoom::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SingleRoom::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SingleRoom::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SingleRoom::clear_player_id() {
  player_id_ = 0u;
  clear_has_player_id();
}
inline ::google::protobuf::uint32 SingleRoom::player_id() const {
  return player_id_;
}
inline void SingleRoom::set_player_id(::google::protobuf::uint32 value) {
  set_has_player_id();
  player_id_ = value;
}

// repeated .network.SingleRoom.RoomPlayer players = 2;
inline int SingleRoom::players_size() const {
  return players_.size();
}
inline void SingleRoom::clear_players() {
  players_.Clear();
}
inline const ::network::SingleRoom_RoomPlayer& SingleRoom::players(int index) const {
  return players_.Get(index);
}
inline ::network::SingleRoom_RoomPlayer* SingleRoom::mutable_players(int index) {
  return players_.Mutable(index);
}
inline ::network::SingleRoom_RoomPlayer* SingleRoom::add_players() {
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network::SingleRoom_RoomPlayer >&
SingleRoom::players() const {
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::network::SingleRoom_RoomPlayer >*
SingleRoom::mutable_players() {
  return &players_;
}

// -------------------------------------------------------------------

// Rooms

// repeated .network.SingleRoom rooms = 1;
inline int Rooms::rooms_size() const {
  return rooms_.size();
}
inline void Rooms::clear_rooms() {
  rooms_.Clear();
}
inline const ::network::SingleRoom& Rooms::rooms(int index) const {
  return rooms_.Get(index);
}
inline ::network::SingleRoom* Rooms::mutable_rooms(int index) {
  return rooms_.Mutable(index);
}
inline ::network::SingleRoom* Rooms::add_rooms() {
  return rooms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network::SingleRoom >&
Rooms::rooms() const {
  return rooms_;
}
inline ::google::protobuf::RepeatedPtrField< ::network::SingleRoom >*
Rooms::mutable_rooms() {
  return &rooms_;
}

// -------------------------------------------------------------------

// ReadyToStart

// -------------------------------------------------------------------

// StartReply

// -------------------------------------------------------------------

// SinglePlayerInfo

// optional uint32 seat = 21;
inline bool SinglePlayerInfo::has_seat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SinglePlayerInfo::set_has_seat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SinglePlayerInfo::clear_has_seat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SinglePlayerInfo::clear_seat() {
  seat_ = 0u;
  clear_has_seat();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::seat() const {
  return seat_;
}
inline void SinglePlayerInfo::set_seat(::google::protobuf::uint32 value) {
  set_has_seat();
  seat_ = value;
}

// optional uint32 id = 1;
inline bool SinglePlayerInfo::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SinglePlayerInfo::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SinglePlayerInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SinglePlayerInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::id() const {
  return id_;
}
inline void SinglePlayerInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 team = 2;
inline bool SinglePlayerInfo::has_team() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SinglePlayerInfo::set_has_team() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SinglePlayerInfo::clear_has_team() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SinglePlayerInfo::clear_team() {
  team_ = 0u;
  clear_has_team();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::team() const {
  return team_;
}
inline void SinglePlayerInfo::set_team(::google::protobuf::uint32 value) {
  set_has_team();
  team_ = value;
}

// optional string nickname = 20;
inline bool SinglePlayerInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SinglePlayerInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SinglePlayerInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SinglePlayerInfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& SinglePlayerInfo::nickname() const {
  return *nickname_;
}
inline void SinglePlayerInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void SinglePlayerInfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void SinglePlayerInfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SinglePlayerInfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* SinglePlayerInfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SinglePlayerInfo::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 role_id = 4;
inline bool SinglePlayerInfo::has_role_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SinglePlayerInfo::set_has_role_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SinglePlayerInfo::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SinglePlayerInfo::clear_role_id() {
  role_id_ = 0u;
  clear_has_role_id();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::role_id() const {
  return role_id_;
}
inline void SinglePlayerInfo::set_role_id(::google::protobuf::uint32 value) {
  set_has_role_id();
  role_id_ = value;
}

// optional uint32 hand_count = 5;
inline bool SinglePlayerInfo::has_hand_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SinglePlayerInfo::set_has_hand_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SinglePlayerInfo::clear_has_hand_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SinglePlayerInfo::clear_hand_count() {
  hand_count_ = 0u;
  clear_has_hand_count();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::hand_count() const {
  return hand_count_;
}
inline void SinglePlayerInfo::set_hand_count(::google::protobuf::uint32 value) {
  set_has_hand_count();
  hand_count_ = value;
}

// optional uint32 heal_count = 6;
inline bool SinglePlayerInfo::has_heal_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SinglePlayerInfo::set_has_heal_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SinglePlayerInfo::clear_has_heal_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SinglePlayerInfo::clear_heal_count() {
  heal_count_ = 0u;
  clear_has_heal_count();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::heal_count() const {
  return heal_count_;
}
inline void SinglePlayerInfo::set_heal_count(::google::protobuf::uint32 value) {
  set_has_heal_count();
  heal_count_ = value;
}

// repeated uint32 my_ex_card_place = 7;
inline int SinglePlayerInfo::my_ex_card_place_size() const {
  return my_ex_card_place_.size();
}
inline void SinglePlayerInfo::clear_my_ex_card_place() {
  my_ex_card_place_.Clear();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::my_ex_card_place(int index) const {
  return my_ex_card_place_.Get(index);
}
inline void SinglePlayerInfo::set_my_ex_card_place(int index, ::google::protobuf::uint32 value) {
  my_ex_card_place_.Set(index, value);
}
inline void SinglePlayerInfo::add_my_ex_card_place(::google::protobuf::uint32 value) {
  my_ex_card_place_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SinglePlayerInfo::my_ex_card_place() const {
  return my_ex_card_place_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SinglePlayerInfo::mutable_my_ex_card_place() {
  return &my_ex_card_place_;
}

// repeated uint32 gain_ex_card = 8;
inline int SinglePlayerInfo::gain_ex_card_size() const {
  return gain_ex_card_.size();
}
inline void SinglePlayerInfo::clear_gain_ex_card() {
  gain_ex_card_.Clear();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::gain_ex_card(int index) const {
  return gain_ex_card_.Get(index);
}
inline void SinglePlayerInfo::set_gain_ex_card(int index, ::google::protobuf::uint32 value) {
  gain_ex_card_.Set(index, value);
}
inline void SinglePlayerInfo::add_gain_ex_card(::google::protobuf::uint32 value) {
  gain_ex_card_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SinglePlayerInfo::gain_ex_card() const {
  return gain_ex_card_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SinglePlayerInfo::mutable_gain_ex_card() {
  return &gain_ex_card_;
}

// repeated uint32 basic_cards = 9;
inline int SinglePlayerInfo::basic_cards_size() const {
  return basic_cards_.size();
}
inline void SinglePlayerInfo::clear_basic_cards() {
  basic_cards_.Clear();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::basic_cards(int index) const {
  return basic_cards_.Get(index);
}
inline void SinglePlayerInfo::set_basic_cards(int index, ::google::protobuf::uint32 value) {
  basic_cards_.Set(index, value);
}
inline void SinglePlayerInfo::add_basic_cards(::google::protobuf::uint32 value) {
  basic_cards_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SinglePlayerInfo::basic_cards() const {
  return basic_cards_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SinglePlayerInfo::mutable_basic_cards() {
  return &basic_cards_;
}

// optional uint32 gem = 10;
inline bool SinglePlayerInfo::has_gem() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SinglePlayerInfo::set_has_gem() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SinglePlayerInfo::clear_has_gem() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SinglePlayerInfo::clear_gem() {
  gem_ = 0u;
  clear_has_gem();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::gem() const {
  return gem_;
}
inline void SinglePlayerInfo::set_gem(::google::protobuf::uint32 value) {
  set_has_gem();
  gem_ = value;
}

// optional uint32 crystal = 11;
inline bool SinglePlayerInfo::has_crystal() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SinglePlayerInfo::set_has_crystal() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SinglePlayerInfo::clear_has_crystal() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SinglePlayerInfo::clear_crystal() {
  crystal_ = 0u;
  clear_has_crystal();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::crystal() const {
  return crystal_;
}
inline void SinglePlayerInfo::set_crystal(::google::protobuf::uint32 value) {
  set_has_crystal();
  crystal_ = value;
}

// optional uint32 yellow_energy = 12;
inline bool SinglePlayerInfo::has_yellow_energy() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SinglePlayerInfo::set_has_yellow_energy() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SinglePlayerInfo::clear_has_yellow_energy() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SinglePlayerInfo::clear_yellow_energy() {
  yellow_energy_ = 0u;
  clear_has_yellow_energy();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::yellow_energy() const {
  return yellow_energy_;
}
inline void SinglePlayerInfo::set_yellow_energy(::google::protobuf::uint32 value) {
  set_has_yellow_energy();
  yellow_energy_ = value;
}

// optional uint32 blue_energy = 13;
inline bool SinglePlayerInfo::has_blue_energy() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SinglePlayerInfo::set_has_blue_energy() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SinglePlayerInfo::clear_has_blue_energy() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SinglePlayerInfo::clear_blue_energy() {
  blue_energy_ = 0u;
  clear_has_blue_energy();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::blue_energy() const {
  return blue_energy_;
}
inline void SinglePlayerInfo::set_blue_energy(::google::protobuf::uint32 value) {
  set_has_blue_energy();
  blue_energy_ = value;
}

// optional uint32 covered_count = 14;
inline bool SinglePlayerInfo::has_covered_count() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SinglePlayerInfo::set_has_covered_count() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SinglePlayerInfo::clear_has_covered_count() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SinglePlayerInfo::clear_covered_count() {
  covered_count_ = 0u;
  clear_has_covered_count();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::covered_count() const {
  return covered_count_;
}
inline void SinglePlayerInfo::set_covered_count(::google::protobuf::uint32 value) {
  set_has_covered_count();
  covered_count_ = value;
}

// optional bool is_knelt = 3;
inline bool SinglePlayerInfo::has_is_knelt() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SinglePlayerInfo::set_has_is_knelt() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SinglePlayerInfo::clear_has_is_knelt() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SinglePlayerInfo::clear_is_knelt() {
  is_knelt_ = false;
  clear_has_is_knelt();
}
inline bool SinglePlayerInfo::is_knelt() const {
  return is_knelt_;
}
inline void SinglePlayerInfo::set_is_knelt(bool value) {
  set_has_is_knelt();
  is_knelt_ = value;
}

// repeated uint32 hands = 15;
inline int SinglePlayerInfo::hands_size() const {
  return hands_.size();
}
inline void SinglePlayerInfo::clear_hands() {
  hands_.Clear();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::hands(int index) const {
  return hands_.Get(index);
}
inline void SinglePlayerInfo::set_hands(int index, ::google::protobuf::uint32 value) {
  hands_.Set(index, value);
}
inline void SinglePlayerInfo::add_hands(::google::protobuf::uint32 value) {
  hands_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SinglePlayerInfo::hands() const {
  return hands_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SinglePlayerInfo::mutable_hands() {
  return &hands_;
}

// repeated uint32 covereds = 16;
inline int SinglePlayerInfo::covereds_size() const {
  return covereds_.size();
}
inline void SinglePlayerInfo::clear_covereds() {
  covereds_.Clear();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::covereds(int index) const {
  return covereds_.Get(index);
}
inline void SinglePlayerInfo::set_covereds(int index, ::google::protobuf::uint32 value) {
  covereds_.Set(index, value);
}
inline void SinglePlayerInfo::add_covereds(::google::protobuf::uint32 value) {
  covereds_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SinglePlayerInfo::covereds() const {
  return covereds_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SinglePlayerInfo::mutable_covereds() {
  return &covereds_;
}

// optional uint32 max_hand = 22;
inline bool SinglePlayerInfo::has_max_hand() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SinglePlayerInfo::set_has_max_hand() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SinglePlayerInfo::clear_has_max_hand() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SinglePlayerInfo::clear_max_hand() {
  max_hand_ = 0u;
  clear_has_max_hand();
}
inline ::google::protobuf::uint32 SinglePlayerInfo::max_hand() const {
  return max_hand_;
}
inline void SinglePlayerInfo::set_max_hand(::google::protobuf::uint32 value) {
  set_has_max_hand();
  max_hand_ = value;
}

// repeated string delete_field = 30;
inline int SinglePlayerInfo::delete_field_size() const {
  return delete_field_.size();
}
inline void SinglePlayerInfo::clear_delete_field() {
  delete_field_.Clear();
}
inline const ::std::string& SinglePlayerInfo::delete_field(int index) const {
  return delete_field_.Get(index);
}
inline ::std::string* SinglePlayerInfo::mutable_delete_field(int index) {
  return delete_field_.Mutable(index);
}
inline void SinglePlayerInfo::set_delete_field(int index, const ::std::string& value) {
  delete_field_.Mutable(index)->assign(value);
}
inline void SinglePlayerInfo::set_delete_field(int index, const char* value) {
  delete_field_.Mutable(index)->assign(value);
}
inline void SinglePlayerInfo::set_delete_field(int index, const char* value, size_t size) {
  delete_field_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SinglePlayerInfo::add_delete_field() {
  return delete_field_.Add();
}
inline void SinglePlayerInfo::add_delete_field(const ::std::string& value) {
  delete_field_.Add()->assign(value);
}
inline void SinglePlayerInfo::add_delete_field(const char* value) {
  delete_field_.Add()->assign(value);
}
inline void SinglePlayerInfo::add_delete_field(const char* value, size_t size) {
  delete_field_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SinglePlayerInfo::delete_field() const {
  return delete_field_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SinglePlayerInfo::mutable_delete_field() {
  return &delete_field_;
}

// -------------------------------------------------------------------

// GameInfo

// repeated .network.SinglePlayerInfo player_infos = 1;
inline int GameInfo::player_infos_size() const {
  return player_infos_.size();
}
inline void GameInfo::clear_player_infos() {
  player_infos_.Clear();
}
inline const ::network::SinglePlayerInfo& GameInfo::player_infos(int index) const {
  return player_infos_.Get(index);
}
inline ::network::SinglePlayerInfo* GameInfo::mutable_player_infos(int index) {
  return player_infos_.Mutable(index);
}
inline ::network::SinglePlayerInfo* GameInfo::add_player_infos() {
  return player_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::network::SinglePlayerInfo >&
GameInfo::player_infos() const {
  return player_infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::network::SinglePlayerInfo >*
GameInfo::mutable_player_infos() {
  return &player_infos_;
}

// optional uint32 red_morale = 2;
inline bool GameInfo::has_red_morale() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameInfo::set_has_red_morale() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameInfo::clear_has_red_morale() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameInfo::clear_red_morale() {
  red_morale_ = 0u;
  clear_has_red_morale();
}
inline ::google::protobuf::uint32 GameInfo::red_morale() const {
  return red_morale_;
}
inline void GameInfo::set_red_morale(::google::protobuf::uint32 value) {
  set_has_red_morale();
  red_morale_ = value;
}

// optional uint32 blue_morale = 3;
inline bool GameInfo::has_blue_morale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameInfo::set_has_blue_morale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameInfo::clear_has_blue_morale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameInfo::clear_blue_morale() {
  blue_morale_ = 0u;
  clear_has_blue_morale();
}
inline ::google::protobuf::uint32 GameInfo::blue_morale() const {
  return blue_morale_;
}
inline void GameInfo::set_blue_morale(::google::protobuf::uint32 value) {
  set_has_blue_morale();
  blue_morale_ = value;
}

// optional uint32 red_gem = 4;
inline bool GameInfo::has_red_gem() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameInfo::set_has_red_gem() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameInfo::clear_has_red_gem() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameInfo::clear_red_gem() {
  red_gem_ = 0u;
  clear_has_red_gem();
}
inline ::google::protobuf::uint32 GameInfo::red_gem() const {
  return red_gem_;
}
inline void GameInfo::set_red_gem(::google::protobuf::uint32 value) {
  set_has_red_gem();
  red_gem_ = value;
}

// optional uint32 blue_gem = 5;
inline bool GameInfo::has_blue_gem() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameInfo::set_has_blue_gem() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameInfo::clear_has_blue_gem() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameInfo::clear_blue_gem() {
  blue_gem_ = 0u;
  clear_has_blue_gem();
}
inline ::google::protobuf::uint32 GameInfo::blue_gem() const {
  return blue_gem_;
}
inline void GameInfo::set_blue_gem(::google::protobuf::uint32 value) {
  set_has_blue_gem();
  blue_gem_ = value;
}

// optional uint32 red_crystal = 6;
inline bool GameInfo::has_red_crystal() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameInfo::set_has_red_crystal() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameInfo::clear_has_red_crystal() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameInfo::clear_red_crystal() {
  red_crystal_ = 0u;
  clear_has_red_crystal();
}
inline ::google::protobuf::uint32 GameInfo::red_crystal() const {
  return red_crystal_;
}
inline void GameInfo::set_red_crystal(::google::protobuf::uint32 value) {
  set_has_red_crystal();
  red_crystal_ = value;
}

// optional uint32 blue_crystal = 7;
inline bool GameInfo::has_blue_crystal() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameInfo::set_has_blue_crystal() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameInfo::clear_has_blue_crystal() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameInfo::clear_blue_crystal() {
  blue_crystal_ = 0u;
  clear_has_blue_crystal();
}
inline ::google::protobuf::uint32 GameInfo::blue_crystal() const {
  return blue_crystal_;
}
inline void GameInfo::set_blue_crystal(::google::protobuf::uint32 value) {
  set_has_blue_crystal();
  blue_crystal_ = value;
}

// optional uint32 red_grail = 8;
inline bool GameInfo::has_red_grail() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameInfo::set_has_red_grail() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameInfo::clear_has_red_grail() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameInfo::clear_red_grail() {
  red_grail_ = 0u;
  clear_has_red_grail();
}
inline ::google::protobuf::uint32 GameInfo::red_grail() const {
  return red_grail_;
}
inline void GameInfo::set_red_grail(::google::protobuf::uint32 value) {
  set_has_red_grail();
  red_grail_ = value;
}

// optional uint32 blue_grail = 9;
inline bool GameInfo::has_blue_grail() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GameInfo::set_has_blue_grail() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GameInfo::clear_has_blue_grail() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GameInfo::clear_blue_grail() {
  blue_grail_ = 0u;
  clear_has_blue_grail();
}
inline ::google::protobuf::uint32 GameInfo::blue_grail() const {
  return blue_grail_;
}
inline void GameInfo::set_blue_grail(::google::protobuf::uint32 value) {
  set_has_blue_grail();
  blue_grail_ = value;
}

// optional uint32 pile = 10;
inline bool GameInfo::has_pile() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GameInfo::set_has_pile() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GameInfo::clear_has_pile() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GameInfo::clear_pile() {
  pile_ = 0u;
  clear_has_pile();
}
inline ::google::protobuf::uint32 GameInfo::pile() const {
  return pile_;
}
inline void GameInfo::set_pile(::google::protobuf::uint32 value) {
  set_has_pile();
  pile_ = value;
}

// optional uint32 discard = 11;
inline bool GameInfo::has_discard() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GameInfo::set_has_discard() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GameInfo::clear_has_discard() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GameInfo::clear_discard() {
  discard_ = 0u;
  clear_has_discard();
}
inline ::google::protobuf::uint32 GameInfo::discard() const {
  return discard_;
}
inline void GameInfo::set_discard(::google::protobuf::uint32 value) {
  set_has_discard();
  discard_ = value;
}

// repeated uint32 show_cards = 12;
inline int GameInfo::show_cards_size() const {
  return show_cards_.size();
}
inline void GameInfo::clear_show_cards() {
  show_cards_.Clear();
}
inline ::google::protobuf::uint32 GameInfo::show_cards(int index) const {
  return show_cards_.Get(index);
}
inline void GameInfo::set_show_cards(int index, ::google::protobuf::uint32 value) {
  show_cards_.Set(index, value);
}
inline void GameInfo::add_show_cards(::google::protobuf::uint32 value) {
  show_cards_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GameInfo::show_cards() const {
  return show_cards_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GameInfo::mutable_show_cards() {
  return &show_cards_;
}

// optional uint32 show_from = 13;
inline bool GameInfo::has_show_from() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GameInfo::set_has_show_from() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GameInfo::clear_has_show_from() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GameInfo::clear_show_from() {
  show_from_ = 0u;
  clear_has_show_from();
}
inline ::google::protobuf::uint32 GameInfo::show_from() const {
  return show_from_;
}
inline void GameInfo::set_show_from(::google::protobuf::uint32 value) {
  set_has_show_from();
  show_from_ = value;
}

// repeated string delete_field = 15;
inline int GameInfo::delete_field_size() const {
  return delete_field_.size();
}
inline void GameInfo::clear_delete_field() {
  delete_field_.Clear();
}
inline const ::std::string& GameInfo::delete_field(int index) const {
  return delete_field_.Get(index);
}
inline ::std::string* GameInfo::mutable_delete_field(int index) {
  return delete_field_.Mutable(index);
}
inline void GameInfo::set_delete_field(int index, const ::std::string& value) {
  delete_field_.Mutable(index)->assign(value);
}
inline void GameInfo::set_delete_field(int index, const char* value) {
  delete_field_.Mutable(index)->assign(value);
}
inline void GameInfo::set_delete_field(int index, const char* value, size_t size) {
  delete_field_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::add_delete_field() {
  return delete_field_.Add();
}
inline void GameInfo::add_delete_field(const ::std::string& value) {
  delete_field_.Add()->assign(value);
}
inline void GameInfo::add_delete_field(const char* value) {
  delete_field_.Add()->assign(value);
}
inline void GameInfo::add_delete_field(const char* value, size_t size) {
  delete_field_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GameInfo::delete_field() const {
  return delete_field_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GameInfo::mutable_delete_field() {
  return &delete_field_;
}

// -------------------------------------------------------------------

// Talk

// optional string txt = 1;
inline bool Talk::has_txt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Talk::set_has_txt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Talk::clear_has_txt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Talk::clear_txt() {
  if (txt_ != &::google::protobuf::internal::kEmptyString) {
    txt_->clear();
  }
  clear_has_txt();
}
inline const ::std::string& Talk::txt() const {
  return *txt_;
}
inline void Talk::set_txt(const ::std::string& value) {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  txt_->assign(value);
}
inline void Talk::set_txt(const char* value) {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  txt_->assign(value);
}
inline void Talk::set_txt(const char* value, size_t size) {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  txt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Talk::mutable_txt() {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  return txt_;
}
inline ::std::string* Talk::release_txt() {
  clear_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txt_;
    txt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Talk::set_allocated_txt(::std::string* txt) {
  if (txt_ != &::google::protobuf::internal::kEmptyString) {
    delete txt_;
  }
  if (txt) {
    set_has_txt();
    txt_ = txt;
  } else {
    clear_has_txt();
    txt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Gossip

// optional .network.GossipType type = 1;
inline bool Gossip::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Gossip::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Gossip::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Gossip::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::network::GossipType Gossip::type() const {
  return static_cast< ::network::GossipType >(type_);
}
inline void Gossip::set_type(::network::GossipType value) {
  assert(::network::GossipType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string txt = 2;
inline bool Gossip::has_txt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Gossip::set_has_txt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Gossip::clear_has_txt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Gossip::clear_txt() {
  if (txt_ != &::google::protobuf::internal::kEmptyString) {
    txt_->clear();
  }
  clear_has_txt();
}
inline const ::std::string& Gossip::txt() const {
  return *txt_;
}
inline void Gossip::set_txt(const ::std::string& value) {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  txt_->assign(value);
}
inline void Gossip::set_txt(const char* value) {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  txt_->assign(value);
}
inline void Gossip::set_txt(const char* value, size_t size) {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  txt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Gossip::mutable_txt() {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  return txt_;
}
inline ::std::string* Gossip::release_txt() {
  clear_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txt_;
    txt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Gossip::set_allocated_txt(::std::string* txt) {
  if (txt_ != &::google::protobuf::internal::kEmptyString) {
    delete txt_;
  }
  if (txt) {
    set_has_txt();
    txt_ = txt;
  } else {
    clear_has_txt();
    txt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 id = 3;
inline bool Gossip::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Gossip::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Gossip::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Gossip::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Gossip::id() const {
  return id_;
}
inline void Gossip::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace network

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::network::MessageType>() {
  return ::network::MessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::network::GossipType>() {
  return ::network::GossipType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_base_2eproto__INCLUDED
